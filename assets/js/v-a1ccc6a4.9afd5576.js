(self.webpackChunkfun_doc=self.webpackChunkfun_doc||[]).push([[4059],{6584:(e,n,o)=>{"use strict";o.r(n),o.d(n,{data:()=>s});const s={key:"v-a1ccc6a4",path:"/interview/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-%E5%8E%9F%E5%9E%8B%E9%93%BEPROTOTYPE.html",title:"前端面试问题-原型链PROTOTYPE",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"JS中的默认继承方式",slug:"js中的默认继承方式",children:[]}],filePathRelative:"interview/前端/前端面试问题-原型链PROTOTYPE.md",git:{updatedTime:162452411e4,contributors:[{name:"caifang",email:"cooldish1245@163.com",commits:1}]}}},6109:(e,n,o)=>{"use strict";o.r(n),o.d(n,{default:()=>t});const s=(0,o(6252).uE)('<h1 id="前端面试问题-原型链prototype"><a class="header-anchor" href="#前端面试问题-原型链prototype">#</a> 前端面试问题-原型链PROTOTYPE</h1><h2 id="js中的默认继承方式"><a class="header-anchor" href="#js中的默认继承方式">#</a> JS中的默认继承方式</h2><ol><li>js中有三种继承方式</li></ol><ul><li><code>call()</code>方式</li><li><code>apply()</code>方式</li><li><code>prototype</code>方式 其中<code>prototype</code>(原型)方式就是js的默认继承方式，另外两种继承方式此处不详细说明。</li></ul><ol start="2"><li>PROTOTYPE 继承 每个对象都可以找到它的prototype对象，有以下两种方式获取prototype对象：</li></ol><ul><li>构造函数名.prototype</li><li>实例对象.<strong>proto</strong> prototype也是一个实例对象，因此其也可以通过自身的构造函数访问它的原型对象，或者通过实例对象访问它的原型对象。 如图： <img src="https://api.icaifun.com/articleImages/1587573123549.png" alt=""></li></ul><p><strong>为什么说JS默认是PROTOTYPE继承</strong> 看例子： 写一个构造函数</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>默认会存在:(可以认为浏览器帮我们做了这件事) <code>Person.prototype = new Object();</code></p><p>即默认让我们的Person对象继承Object对象。因此我们才能直接调用这样的方法</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p><strong>原型链就是指如何通过实例对象访问其继承的对象。</strong></p><p>访问Person的原型对象：</p><ul><li>通过<code>Person.prototype</code>访问</li><li>通过<code>new Person().__proto__</code>访问</li></ul><p>而我们知道了<code>Person.prototype = new Object()</code>;，即有Person的原型对象的构造方法是Object。</p><p>访问Person的原型对象的原型对象：</p><ul><li><code>Person.prototype.__proto__</code></li><li><code>Object.prototype</code></li></ul><p>这个对象是存在的。</p><p>如果再访问其原型对象呢：</p><ul><li><code>Object.prototype.__proto__</code> 为null 不存在了。</li></ul><p>原型链有点绕，我们可以在浏览器console控制台中打印查看各个数据。</p><p>完善上面的图： <img src="https://api.icaifun.com/articleImages/1587573461720.png" alt=""> 当我们通过<code>new Person().name</code>这样的方式找对象属性时，就会根据原型链，层层往上找。</p><p>结论：</p><ul><li>一个普通对象的原型对象是Object的实例:<code>new Object()</code></li><li>原型对象的原型对象仍然存在，即<code>Object.prototype </code>存在</li><li>再往上追上述对象的原型对象，就不存在了。即<code>Object.prototype.__proto__</code>为null</li></ul>',24),t={render:function(e,n){return s}}}}]);